---
title: Machine Epsilon
thumbnail: ''
draft: false
tags:
- round-off-error
- epsilion
- machine-epsilon
- floating-point
created: 2023-12-14
---

# 실수 표현

* [부동 소수점](https://ko.wikipedia.org/wiki/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90)으로 표현한다.
* 지표 + 가수로 표현된다.
* 왜 쓰는가?
* 고정 소수점으로 쓸 경우, 큰 수 ($10^23)$ 과 같은 수를 표현하기 위해 많은 양의 비트가 필요하게 된다.
* 하지만 이를 실제 숫자를 나타내는 구간과, 자리수를 나타내는 구간으로 분리한다면 정보를 보다 효율적으로 저장할 수 있게 된다.

![](Screen%20Shot%202023-12-14%20at%204.30.23%20PM.png)

* 8byte인 실수의 표현 방식을 정리하면 위와 같다.
* 앞에는 부호 비트, 지수 표현, 가수 표현이다.
* 지수의 경우 자리수를 표현하는 $10^x$를 대변하는 것이고,
* 가수의 경우 숫자의 모양을 나타낸다.

## 예시

 > 
 > −118.625 (십진법)을 IEEE 754 (32비트 단정밀도)로 표현해 보자.

* 음수이므로, 부호부는 1이 된다.
* 그 다음, 절댓값을 이진법으로 나타내면 1110110.101이 된다.
* 소수점을 왼쪽으로 이동시켜, 왼쪽에는 1만 남게 만든다. 예를 들면 1110110.101=1.110110101×2⁶ 과 같다. 이것을 정규화된 부동소수점 수라고 한다.
* 가수부는 소수점의 오른쪽 부분으로, 부족한 비트 수 부분만큼 0으로 채워 23비트로 만든다. 결과는 11011010100000000000000이 된다.
* 지수는 6이므로, Bias를 더해야 한다. 32비트 IEEE 754 형식에서는 Bias는 127이므로 6+127 = 133이 된다. 이진법으로 변환하면 10000101이 된다.

## Bias를 왜 더해?

* 지수부에는 따로 부호 비트가 없기 때문에 음수 지수를 처리하기 위해 보통 바이어스 표현법을 사용한다. 
* 즉, 할당된 자릿수로 표현 가능한 전체 영역을 반으로 나누어, 작은 영역에는 음수값 및 0, 큰 영역에는 양수값이 차례대로 1:1 대응되도록 한다. 
* 예를 들어, 지수부를 8비트로 표현한다면 모두 256가지 수를 나타낼 수 있는데 이것을 반으로 나누어 음수 127개와 0, 양수 128개를 차례대로 대응시킨다. 
* 따라서, 비트열 00000000은 지수 -127을 나타내고, 01111111은 지수 0, 11111111은 지수 128을 나타낸다. 
* 일반적으로는 지수부가 n비트일 때 (2n / 2 - 1 = 2n-1 - 1)을 지수 값에 더하며 이것을 바이어스 상수라고 한다.
  * 다만, 지수부의 모든 자리가 모두 0 또는 1인 경우는 각각 0 또는 무한대를 나타내는 등 종종 특수한 목적으로 예약되어 있다.)
* 가수부에서는 정규화 결과 유효숫자의 첫째 자리는 언제나 1이므로 표시하지 않고, 소수 부분만 표현한다.

# 발생하는 문제

* 수학은 이상적인 학문에 가깝다.
* 그런 이상적 상황에서의 연산 결과 역시 이상이다.
* 하지만 컴퓨터에서의 연산 결과는 그 이상을 현실로 내려서 나오게 된다.
* 즉, 0.00001 이라는 실수가 있을 때, 이를 기계에서 처리할 수 있는 방식으로 변환하게 되는데,
* 이 과정에서 **정보 손실**이 발생한다.
* 무한에 가까운 숫자를 만들 수 있는 실수구조에서 이를 제한적으로 표현할 수 있는 기계로 내린다면 당연히 발생할 수 밖에 없다.

````swift
var result = 0.0
for _ in 0..<100000 {
	result += 0.00001
}

XCTAssert(result == 1) // false
````

* 그렇기에 실수 타입으로 선언된 연산을 여러번 수행뒤, 예상했던 결과와 비교하면 틀리다고 나오게 된다.

# Machine Epsilon

* 가수로 표현되는 $2^{-23}$ 보다 큰 에러는 발생할 수 없다.
* 이 값은 시스템에서 실수를 어떻게 정의하냐에 따라 달라질 것이다.

# 산술결과에서의 에러

* 값 하나에서의 최대 에러를 알아보았다.
* 그러면 이 결과들에 대해 연산을 했을 때의 결과는 어떻게 될까?
* 위의 예시에서 100000번 더한다고 한다면 $\epsilon \times 100000$에 해당하는 에러가 나오는 것이 아닐까?
* 즉, 연산의 결과도 Machine Epsilon내에 존재한다고 할 수 있는가?
* 아니다. 에러는 누적된다.

 > 
 > Errors can be magnified or accumulated when a sequence of calculations is applied on an initial input with roundoff error due to inexact representation.

# 새길 것

* **실수의 부등식 연산, 산술 연산의 경우에는 Round Off Error를 고려하면서 처리해야 한다.**

# Reference

* [계산기 엡실론](https://ko.wikipedia.org/wiki/%EA%B3%84%EC%82%B0%EA%B8%B0_%EC%97%A1%EC%8B%A4%EB%A1%A0)
* [Machine epsilon](https://en.wikipedia.org/wiki/Machine_epsilon)
* [부동 소수점](https://ko.wikipedia.org/wiki/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90)
* 
